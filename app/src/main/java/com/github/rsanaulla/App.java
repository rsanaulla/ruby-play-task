/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.github.rsanaulla;

import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.concurrent.ThreadLocalRandom;

public class App {

    static double CONFIDENCE_LEVEL_50_TABLE_VALUE = 0.677;
    static double CONFIDENCE_LEVEL_70_TABLE_VALUE = 1.042;
    static double CONFIDENCE_LEVEL_80_TABLE_VALUE = 1.290;
    static double CONFIDENCE_LEVEL_95_TABLE_VALUE = 1.984;

    public static double round(double x, int s) {
        double scale = Math.pow(10, s);
        return Math.floor(x * scale) / scale;
    }

    public static void fillProbabilityMapFromArray(double[] source, HashMap<Double, Double> mp) {
        int size = source.length;
        
        for (int i = 0; i < size; i++) {
            double elem = source[i];
            Double value = mp.get(elem);

            if (value != null) {
                mp.put(elem, round(value + (1.0 / (double) size), 3));
            } else {
                mp.put(elem, (1.0 / (double) size));
            }
        }
    }

    public static void fillProbabilityMapFromList(List<Double> source, HashMap<Double, Double> mp) {
        int size = source.size();

        for (int i = 0; i < size; i++) {
            double elem = source.get(i);
            Double value = mp.get(elem);

            if (value != null) {
                mp.put(elem, round(value + (1.0 / (double) size), 3));
            } else {
                mp.put(elem, round((1.0 / (double) size), 3));
            }
        }
    }

    public static double mathExpectedValue(HashMap<Double, Double> probabilityMap) {
        double res = 0.0;

        for (Double value : probabilityMap.keySet()) {
            res += value * probabilityMap.get(value);
        }

        return round(res, 3);
    }

    public static double getAverage(double[] arr) {
        double sum = 0;

        for (int i = 0; i < arr.length; i++) {
            sum += arr[i];
        }

        return round(sum / arr.length, 3);
    }

    public static double dispersion(HashMap<Double, Double> probabilityMap, double mathExpVal) {
        double acc = 0.0;
        double squredMathExpVal = Math.pow(mathExpVal, 2);

        for (Double value : probabilityMap.keySet()) {
            double res = Math.pow(value, 2) * probabilityMap.get(value);
            acc += res;
        }

        return round(acc - squredMathExpVal, 3);
    }

    public static void writeArrayToFile(FileWriter fw, double[] arr, String title) throws IOException {
        fw.write(title + "\n");

        for (int i = 0; i < arr.length; i++) {
            fw.write("Element №: " + i + " = " + arr[i] + "\n");
        }
    }

    public static void writeListToFile(FileWriter fw, List<Double> lst, String title) throws IOException {
        fw.write(title + "\n");

        for (int i = 0; i < lst.size(); i++) {
            fw.write("Element №: " + i + " = " + lst.get(i) + "\n");
        }
    }

    public static double getRandomNoise(Double range) {
        return round(ThreadLocalRandom.current().nextDouble(-range, range), 3);
    }

    public static Limits getConfidenceIntervals(double[] arr, double std, double tableValue) {
        double average = getAverage(arr);
        double standardError = std / Math.sqrt(arr.length);
        double upper = round(average + tableValue * standardError, 3);
        double lower = round(average - tableValue * standardError, 3);

        return new Limits(upper, lower);
    }

    public static void main(String[] args) {
        if (args.length < 3) throw new IllegalArgumentException("You must provide base, tolerance and number of elements");
        double base = Double.parseDouble(args[0]);
        double tolVal = Double.parseDouble(args[1]);
        int numberOfElements = Integer.parseInt(args[2]);

        double[] result = new double[numberOfElements];

        // System.out.println("Generating base array...");
        for (int i = 0; i < numberOfElements; i++) {
            double noise = getRandomNoise(tolVal);
            result[i] = base + noise;
        }

        double tolVal2 = 2 * tolVal * 0.1;
        double upperBound = base + tolVal2;
        double lowerBound = base - tolVal2;

        // dynamicly sized array
        List<Double> filtred = new ArrayList<Double>();
        for (int i = 0; i < numberOfElements; i++) {
            double elem = result[i];
            if (elem <= upperBound && elem >= lowerBound) {
                filtred.add(elem);
            }
        }
        int filterSize = filtred.size();

        double percentOfFiltredValues = round((filterSize / (double) numberOfElements) * 100, 3);

        HashMap<Double, Double> probabilityMap = new HashMap<Double, Double>();
        fillProbabilityMapFromArray(result, probabilityMap);

        HashMap<Double, Double> probabilityOfFiltredMap = new HashMap<Double, Double>();
        fillProbabilityMapFromList(filtred, probabilityOfFiltredMap);

        HashMap<Double, Double> probabilityOfFallingInFiltredMap = new HashMap<Double, Double>();
        for (Double name : probabilityMap.keySet()) {
            Double value = probabilityOfFiltredMap.get(name);
            if (value != null) {
                probabilityOfFallingInFiltredMap.put(name, value * probabilityMap.get(name));
            } else {
                probabilityOfFallingInFiltredMap.put(name, 0.0);
            }
        }

        HashMap<Double, Double> frequencyOfAppearanceInFallingSet = new HashMap<Double, Double>();
        for (Double name : probabilityOfFallingInFiltredMap.keySet()) {
            if (filterSize != 0) {
                frequencyOfAppearanceInFallingSet.put(name,
                        round(probabilityOfFallingInFiltredMap.get(name) / filterSize, 3));
            } else {
                frequencyOfAppearanceInFallingSet.put(name, 0.0);
            }
        }

        double mathExpectedValueGenerated = mathExpectedValue(probabilityMap);
        // System.out.println("Math expected value for all generated values: " + round(mathExpectedValueGenerated, 3));

        double mathExpectedValueFiltred = mathExpectedValue(probabilityOfFiltredMap);
        // System.out.println("Math expected value for filtred values: " + round(mathExpectedValueFiltred, 3));

        double dispersionGenerated = dispersion(probabilityMap, mathExpectedValueGenerated);
        // System.out.println("Dispersion value for all generated values: " + round(dispersionGenerated, 3));

        double dispersionFiltred = dispersion(probabilityOfFiltredMap, mathExpectedValueFiltred);
        // System.out.println("Dispersion value for filtred values: " + round(dispersionFiltred, 3));

        double stdGenerated = round(Math.sqrt(dispersionGenerated), 3);
        // System.out.println("Standard square deviation all generated values: " + round(stdGenerated, 3));

        double stdFiltred = round(Math.sqrt(dispersionFiltred), 3);
        // System.out.println("Standard square deviation for filtred values: " + round(stdFiltred, 3));

        Limits confInterval50 = getConfidenceIntervals(result, stdGenerated, CONFIDENCE_LEVEL_50_TABLE_VALUE);
        Limits confInterval70 = getConfidenceIntervals(result, stdGenerated, CONFIDENCE_LEVEL_70_TABLE_VALUE);
        Limits confInterval80 = getConfidenceIntervals(result, stdGenerated, CONFIDENCE_LEVEL_80_TABLE_VALUE);
        Limits confInterval95 = getConfidenceIntervals(result, stdGenerated, CONFIDENCE_LEVEL_95_TABLE_VALUE);

        try {
            FileWriter fw = new FileWriter("report.txt");

            fw.write("Base: " + base + "\n");
            fw.write("Tolerance: " + tolVal + "\n");
            fw.write("Number of initial elements: " + numberOfElements + "\n");

            fw.write("\n");

            writeArrayToFile(fw, result, "Initally generated array");
            fw.write("Mathematical expected value: " + mathExpectedValueGenerated + "\n");
            fw.write("Dispersion: " + dispersionGenerated + "\n");
            fw.write("Standard deviation: " + stdGenerated + "\n");

            fw.write("\n");

            writeListToFile(fw, filtred, "Filtred array");
            fw.write("Mathematical expected value: " + mathExpectedValueFiltred + "\n");
            fw.write("Dispersion: " + dispersionFiltred + "\n");
            fw.write("Standard deviation: " + stdFiltred + "\n");
            fw.write("\n");

            fw.write("Filtred values in entire range: " + percentOfFiltredValues + "%" + "\n");

            fw.write("Limits for level 50 -> (lower: " + confInterval50.upperLimit + ", upper: "
                    + confInterval50.lowerLimit + ")" + "\n");
            fw.write("Limits for level 70 -> (lower: " + confInterval70.upperLimit + ", upper: "
                    + confInterval70.lowerLimit + ")" + "\n");
            fw.write("Limits for level 80 -> (lower: " + confInterval80.upperLimit + ", upper: "
                    + confInterval80.lowerLimit + ")" + "\n");
            fw.write("Limits for level 95 -> (lower: " + confInterval95.upperLimit + ", upper: "
                    + confInterval95.lowerLimit + ")" + "\n");

            for (int i = 0; i < result.length; i++) {
                double value = result[i];
                if (confInterval50.isInside(value))
                    confInterval50.hit();
                else if (confInterval70.isInside(value))
                    confInterval70.hit();
                else if (confInterval80.isInside(value))
                    confInterval80.hit();
                else
                    confInterval95.hit();
            }

            fw.write("Hit rate for confidence level 50: " + confInterval50.hits + "\n");
            fw.write("Hit rate for confidence level 70: " + confInterval70.hits + "\n");
            fw.write("Hit rate for confidence level 80: " + confInterval80.hits + "\n");
            fw.write("Hit rate for confidence level 95: " + confInterval95.hits + "\n");

            fw.close();
        } catch (Exception e) {
            e.getStackTrace();
        }

    }
}
